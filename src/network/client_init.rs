use std::{
    io::{self, Read},
    net::{IpAddr, TcpStream},
    ptr::null,
    str::FromStr,
};

use bevy::ecs::{
    schedule::NextState,
    system::{Commands, Res, ResMut, Resource},
};
use bevy_oxr::{
    resources::{XrInstance, XrSession},
    xr::{
        sys::{
            SpaceQueryInfoFB, SpaceStorageLocationFilterInfoFB, SpaceUserFB, SpaceUuidFilterInfoFB,
        },
        AsyncRequestIdFB, Duration, SpaceQueryActionFB, SpaceStorageLocationFB, UuidEXT,
    },
};

#[cfg(target_os = "android")]
use crate::ovr::Ovr;
use crate::{oxr, xr::SceneState};

use super::{multicast::MulticastEmitter, NetworkingState, RemoteAddresses};

// This resource is used by the client to send multicast packets
// created: client_init | dropped: client_await_data
#[derive(Resource)]
pub(super) struct MulticastEmitterRes(MulticastEmitter);

// Initialize the multicast emitter with our own SpaceUserFB ID
#[cfg(not(target_os = "android"))]
pub(super) fn client_init(mut commands: Commands) {
    let emitter = MulticastEmitter::new(SpaceUserFB::NULL);
    commands.insert_resource(MulticastEmitterRes(emitter));
}

// Initialize the multicast emitter with our own SpaceUserFB ID
#[cfg(target_os = "android")]
pub(super) fn client_init(mut commands: Commands, ovr: Res<Ovr>) {
    // TODO: figure out how to get FB ID
    let id = ovr.get_logged_in_user_id();
    panic!("User ID: {id}");
    let emitter = MulticastEmitter::new(SpaceUserFB::from_raw(id));
    commands.insert_resource(MulticastEmitterRes(emitter));
}

// This is the stream generated by the listener accepting incoming data
// created: client_establish_tcp | dropped: client_await_data
#[derive(Resource)]
pub(super) struct HostConnection(TcpStream);

pub(super) fn client_establish_tcp(
    mut state: ResMut<NextState<NetworkingState>>,
    mut commands: Commands,
    emit: Res<MulticastEmitterRes>,
) {
    let emit = &emit.0;

    // First we do a listen to see if we've got any incoming connections
    if let Some((stream, _)) = emit.accept() {
        commands.insert_resource(HostConnection(stream));
        state.0 = Some(NetworkingState::ClientWaitForData);
        return;
    } else {
        // If we there are no incoming requests then we emit a new multicast message
        // TODO: put this on a timer
        emit.emit();
    }
}

#[derive(Resource)]
pub(super) struct AnchorUuid(UuidEXT);

pub(super) fn client_await_data(
    mut commands: Commands,
    mut state: ResMut<NextState<NetworkingState>>,
    mut stream: ResMut<HostConnection>,
) {
    let stream = &mut stream.0;
    let mut buf = Vec::new();

    match stream.read_to_end(&mut buf) {
        Ok(len) => {
            // Gather the Space ID and all valid IPs from the message we've been sent
            let mut fields = buf[..len].split(|chr| *chr == 0);
            let space_uuid: u128 = std::str::from_utf8(fields.next().unwrap())
                .unwrap()
                .parse()
                .unwrap();
            commands.insert_resource(AnchorUuid(UuidEXT {
                data: space_uuid.to_be_bytes(),
            }));

            let mut ips = fields
                .map(|slice| IpAddr::from_str(std::str::from_utf8(slice).unwrap()).unwrap())
                .collect::<Vec<_>>();
            // The host doesn't know it's own IP, so it isn't included in the message. We add it here.
            ips.push(stream.peer_addr().unwrap().ip());
            commands.insert_resource(RemoteAddresses(ips));
            commands.remove_resource::<MulticastEmitterRes>();
            commands.remove_resource::<HostConnection>();
            state.0 = Some(NetworkingState::Done);
        }
        Err(err) if err.kind() == io::ErrorKind::WouldBlock => return,
        Err(err) if err.kind() == io::ErrorKind::ConnectionReset => return,
        Err(err) => panic!("{err:?} on {:?}", stream),
    };
}

pub(super) fn client_sync_anchor(
    scene_state: Option<ResMut<NextState<SceneState>>>,
    instance: Option<Res<XrInstance>>,
    session: Option<Res<XrSession>>,
    anchor: Res<AnchorUuid>,
) {
    let (Some(instance), Some(session)) = (instance, session) else {
        return;
    };

    let filter = Box::leak(Box::new(SpaceUuidFilterInfoFB {
        ty: SpaceUuidFilterInfoFB::TYPE,
        next: null(),
        uuid_count: 1,
        uuids: [anchor.0].as_mut_ptr(),
    }));

    let filter = Box::leak(Box::new(SpaceStorageLocationFilterInfoFB {
        ty: SpaceStorageLocationFilterInfoFB::TYPE,
        next: filter as *mut _ as *mut _,
        location: SpaceStorageLocationFB::CLOUD,
    }));

    let query = Box::leak(Box::new(SpaceQueryInfoFB {
        ty: SpaceQueryInfoFB::TYPE,
        next: null(),
        query_action: SpaceQueryActionFB::LOAD,
        max_result_count: 20u32,
        timeout: Duration::NONE,
        filter: filter as *const _ as *const _,
        exclude_filter: null(),
    }));

    let vtable = instance.exts().fb_spatial_entity_query.unwrap();
    let mut request_id: AsyncRequestIdFB = AsyncRequestIdFB::from_raw(0);

    oxr!((vtable.query_spaces)(
        session.as_raw(),
        query as *const _ as *const _,
        &mut request_id,
    ));

    // If we're running this in conjunction with the ScenePlugin then we should
    // notify it that we're awaiting an anchor and it should handle that
    if let Some(mut scene_state) = scene_state {
        scene_state.0 = Some(SceneState::QueryingScene);
    }
}
