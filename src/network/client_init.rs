use std::{
    io::{self, Read},
    net::{IpAddr, TcpStream},
    ptr::{null, null_mut},
    str::FromStr,
    sync::Arc,
};

use bevy::prelude::*;
use bevy_oxr::{
    input::XrInput,
    resources::{XrFrameState, XrInstance, XrSession},
    xr::{
        sys::{
            self, Space, SpaceLocation, SpaceQueryInfoFB, SpaceStorageLocationFilterInfoFB,
            SpaceUserFB, SpaceUuidFilterInfoFB,
        },
        AsyncRequestIdFB, Event, Posef, SpaceLocationFlags, SpaceQueryActionFB,
        SpaceStorageLocationFB, UuidEXT,
    },
    XrEvents,
};

#[cfg(target_os = "android")]
use crate::ovr::Ovr;
use crate::{
    oxr,
    xr::{
        scene::{get_query_results, make_space_locatable},
        SpatialAnchors,
    },
};

use super::{multicast::MulticastEmitter, NetworkingState, RemoteAddresses};

// This resource is used by the client to send multicast packets
// created: client_init | dropped: client_await_data
#[derive(Resource)]
pub(super) struct MulticastEmitterRes(MulticastEmitter);

// This is a timer to be used for sending multicast discovery packets
// created: client_init | dropped: client_establish_tcp
#[derive(Resource)]
pub(super) struct MulticastTimer(Timer);

impl MulticastTimer {
    fn new() -> Self {
        Self(Timer::new(
            std::time::Duration::from_millis(500),
            TimerMode::Repeating,
        ))
    }
}

// Initialize the multicast emitter with our own SpaceUserFB ID
#[cfg(not(target_os = "android"))]
pub(super) fn client_init(mut commands: Commands) {
    let emitter = MulticastEmitter::new(0);
    commands.insert_resource(MulticastEmitterRes(emitter));
    commands.insert_resource(MulticastTimer::new());
}

// Initialize the multicast emitter with our own SpaceUserFB ID
#[cfg(target_os = "android")]
pub(super) fn client_init(mut commands: Commands, ovr: Res<Ovr>) {
    let id = ovr.get_logged_in_user_id();
    println!("Logged in User ID: {id}");
    let emitter = MulticastEmitter::new(id);
    commands.insert_resource(MulticastEmitterRes(emitter));
    commands.insert_resource(MulticastTimer::new());
}

// This is the stream generated by the listener accepting incoming data
// created: client_establish_tcp | dropped: client_await_data
#[derive(Resource)]
pub(super) struct HostConnection(TcpStream);

pub(super) fn client_establish_tcp(
    mut state: ResMut<NextState<NetworkingState>>,
    mut commands: Commands,
    emit: Res<MulticastEmitterRes>,
    mut timer: ResMut<MulticastTimer>,
    time: Res<Time>,
) {
    let emit = &emit.0;

    // First we do a listen to see if we've got any incoming connections
    if let Some((stream, _)) = emit.accept() {
        commands.remove_resource::<MulticastTimer>();
        commands.insert_resource(HostConnection(stream));
        state.0 = Some(NetworkingState::ClientWaitForData);
    } else if timer.0.finished() {
        println!("PING!");
        emit.emit();
    }
    timer.0.tick(time.delta());
}

#[derive(Resource, Debug)]
pub(super) struct AnchorUuid(UuidEXT);

pub(super) fn client_await_data(
    mut commands: Commands,
    mut state: ResMut<NextState<NetworkingState>>,
    mut stream: ResMut<HostConnection>,
) {
    println!("client_await_data");
    let stream = &mut stream.0;
    let mut buf = Vec::new();

    use io::ErrorKind::*;
    match stream.read_to_end(&mut buf) {
        Ok(len) => {
            // Gather the Space ID and all valid IPs from the message we've been sent
            let mut fields = buf[..len].split(|chr| *chr == 0);
            let space_uuid: u128 = std::str::from_utf8(fields.next().unwrap())
                .unwrap()
                .parse()
                .unwrap();
            let uuid = AnchorUuid(UuidEXT {
                data: space_uuid.to_be_bytes(),
            });
            println!("Synchronizing on anchor {space_uuid:?}");
            commands.insert_resource(uuid);

            let mut ips = fields
                .map(|slice| IpAddr::from_str(std::str::from_utf8(slice).unwrap()).unwrap())
                .collect::<Vec<_>>();
            // The host doesn't know it's own IP, so it isn't included in the message. We add it here.
            ips.push(stream.peer_addr().unwrap().ip());
            commands.insert_resource(RemoteAddresses(ips));
            commands.remove_resource::<MulticastEmitterRes>();
            commands.remove_resource::<HostConnection>();
            state.set(NetworkingState::ClientSynchronizeAnchor);
        }
        Err(err) if matches!(err.kind(), WouldBlock | ConnectionReset) => {}
        Err(err) => panic!("{err:?} on {:?}", stream),
    }
}

pub(super) fn client_query_anchor(
    instance: Res<XrInstance>,
    session: Res<XrSession>,
    anchor: Res<AnchorUuid>,
) {
    println!("client_query_anchor");
    let mut uuid = [anchor.0];
    let filter = SpaceUuidFilterInfoFB {
        ty: SpaceUuidFilterInfoFB::TYPE,
        next: null(),
        uuid_count: 1,
        uuids: uuid.as_mut_ptr(),
    };

    let filter = SpaceStorageLocationFilterInfoFB {
        ty: SpaceStorageLocationFilterInfoFB::TYPE,
        next: &filter as *const _ as *const _,
        location: SpaceStorageLocationFB::CLOUD,
    };

    let query = SpaceQueryInfoFB {
        ty: SpaceQueryInfoFB::TYPE,
        next: null(),
        query_action: SpaceQueryActionFB::LOAD,
        max_result_count: 20, // TODO: figure out this number. It should probably be 1 tbh.
        timeout: sys::Duration::INFINITE,
        filter: &filter as *const _ as *const _,
        exclude_filter: null(),
    };

    let vtable = instance.exts().fb_spatial_entity_query.unwrap();
    let mut request_id = AsyncRequestIdFB::default();

    oxr!((vtable.query_spaces)(
        session.as_raw(),
        &query as *const _ as *const _,
        &mut request_id,
    ));
}

// This function waits for our query to complete
pub fn client_sync_anchor(
    mut commands: Commands,
    instance: Res<XrInstance>,
    session: Res<XrSession>,
    events: NonSend<XrEvents>,
    mut state: ResMut<NextState<NetworkingState>>,
) {
    println!("client_sync_anchor");
    for event in &events.0 {
        let event = unsafe { Event::from_raw(&event.inner) }.unwrap();
        match event {
            // Report once the event is complete, and warn if it's failed
            Event::SpaceQueryCompleteFB(query) => {
                let result = query.result();
                if result == bevy_oxr::xr::sys::Result::SUCCESS {
                    info!("Space Query Completed Successfully");
                } else {
                    warn!(
                        r#"Space Query Completed {:?} Failed With Error "{}""#,
                        query.request_id(),
                        result
                    )
                }
            }
            Event::SpaceQueryResultsAvailableFB(resultsAvailable) => {
                let exts = instance.exts();
                let results = get_query_results(resultsAvailable, session.as_raw(), exts);
                let anchor = results[0].space;
                make_space_locatable(anchor, exts);
                let anchors = SpatialAnchors {
                    position: anchor,
                    ..default()
                };
                commands.insert_resource(anchors);
                state.set(NetworkingState::InitGgrs);
            }
            _ => {}
        }
    }
}

pub fn client_use_anchor(
    mut commands: Commands,
    instance: Res<XrInstance>,
    input: Res<XrInput>,
    xr_frame_state: Res<XrFrameState>,
    anchors: Res<SpatialAnchors>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let mut space_location = SpaceLocation {
        ty: SpaceLocation::TYPE,
        next: null_mut(),
        location_flags: SpaceLocationFlags::EMPTY,
        pose: Posef::IDENTITY,
    };
    oxr!((instance.fp().locate_space)(
        anchors.position,
        input.stage.as_raw(),
        xr_frame_state.predicted_display_time,
        &mut space_location,
    ));
    let translation = space_location.pose.position;

    println!("Spawning Anchor Marker");
    commands.spawn(PbrBundle {
        mesh: meshes.add(Cuboid::new(0.2, 0.2, 0.2)),
        material: materials.add(Color::SILVER),
        transform: Transform {
            translation: Vec3 {
                x: translation.x,
                y: translation.y,
                z: translation.z,
            },
            ..default()
        },
        ..default()
    });
}

